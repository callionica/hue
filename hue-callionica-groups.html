<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--<meta name="apple-mobile-web-app-capable" content="yes" />-->
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Rooms & Zones</title>
    <link rel="stylesheet" href="hue-callionica.css">
    <script type="module">
        import { loadCurrentBridge, loadConnection } from "./hue-callionica-connect.js";
        import { sortBy, getAll, setSensorValue, setGroupOn, setRuleActions, createSchedule, getConnectedComponents, deleteComponent, deleteSchedule, displayLocalTime } from "./hue-callionica.js";

        let bridge;
        let connection;
        let data;

        async function update() {
            if (bridge === undefined) {
                bridge = loadCurrentBridge();
            }

            if (connection === undefined) {
                try {
                    connection = await loadConnection("Callionica", bridge);
                } catch (e) {
                    console.log(bridge, e);
                    throw e;
                    // document.querySelector("iframe").src = `https://${bridge.ip}/api/unauthenticated/config`;
                    // connection = await loadConnection("Callionica", bridge);
                }
            }

            const d = document.getElementById("data");

            data = await getAll(connection);
            
            let groups = Object.values(data.groups);

            groups.sort(sortBy(g => g.name));

            const params = new URLSearchParams(document.location.search);

            function getList(name) {
                const p = params.get(name);
                return p?.split(",").map(x => x.trim().toLowerCase());
            }

            const include = getList("include");
            if (include) {
                // Keep name sorting, but only for the listed items
                groups = groups.filter(g => include.includes(g.name.toLowerCase()));

                // If we wanted to use the sort order from include as well, we'd do this:
                // groups = include.map(n => groups.find(g => n === g.name.toLowerCase())).filter(x=>x);
            }

            const exclude = getList("exclude");
            if (exclude) {
                groups = groups.filter(g => !exclude.includes(g.name.toLowerCase()));
            }

            let preferred = getList("sort");
            if (preferred) {
                const x = new Array(preferred.length);
                const y = [];
                for (const group of groups) {
                    const index = preferred.indexOf(group.name.toLowerCase());
                    if (index >= 0) {
                        x[index] = group;
                    } else {
                        y.push(group);
                    }
                }
                
                groups = [...x.filter(x=>x), ...y];
            }

            const components = Object.values(data.components);

            const elements = groups.map(group => {
                const connections = getConnectedComponents(group, data);

                // console.log(group);
                // console.log(connections);

                const powerManagedZone = connections.find(connection => connection.metadata.name === "Power Managed Zone" && connection.metadata.manufacturer === "Callionica");

                // console.log(powerManagedZone);

                function summarizeLights(group, data) {
                    if (group.lights.length === 0) {
                        return { anyOn: false, allOn: false, anyUnreachable: true, allUnreachable: true };
                    }

                    let anyOn = false;
                    let allOn = true;
                    let anyUnreachable = false;
                    let allUnreachable = true;

                    for (const lightID of group.lights) {
                        const light = data.lights[lightID];

                        const unreachable = !light.state.reachable;
                        const on = (light.state.on && light.state.reachable);

                        if (on) {
                            anyOn = true;
                        }

                        allOn = allOn && on;

                        if (unreachable) {
                            anyUnreachable = true;
                        }

                        allUnreachable = allUnreachable && unreachable;
                    }

                    return { anyOn, allOn, anyUnreachable, allUnreachable };
                }

                function getPowerLevel(pmz) {
                    return pmz?.sensors.find(sensor => sensor.metadata.modelid === "PM.Zone.PowerLevel")?.value;
                }

                function getPowerManagement(pmz) {
                    return pmz?.sensors.find(sensor => sensor.metadata.modelid === "PM.Zone.PowerManagement")?.value;
                }

                const lights = summarizeLights(group, data);

                const powerLevel = getPowerLevel(powerManagedZone);
                const powerManagement = getPowerManagement(powerManagedZone);

                function create() {
                    const e = document.createElement("div");
                    e.id = "group-" + group.id;
                    e.innerHTML = `<div><span class="group-name"></span><button class="group-toggle" data-action="toggle"></button></div><div class="controls"></div>`;
                    return e;
                }

                const e = document.getElementById("group-" + group.id) || create();

                const ds = e.dataset;

                ds.group = group.id;
                ds.type = group.type;
                
                ds.anyOn = lights.anyOn;
                ds.allOn = lights.allOn;
                ds.anyUnreachable = lights.anyUnreachable;
                ds.allUnreachable = lights.allUnreachable;

                if (powerLevel) {
                    ds.powerLevel = powerLevel.value;
                } else if (ds.powerLevel) {
                    delete ds.powerLevel;
                }

                if (powerManagement) {
                    ds.powerManagement = powerManagement.value;
                } else if (ds.powerManagement) {
                    delete ds.powerManagement;
                }

                ds.turnOn = !lights.anyOn;
                if (powerLevel) {
                    ds.turnOn = powerLevel.value < 2;
                }

                if (powerManagement) {
                    ds.action = "select";
                }

                e.querySelector(".group-name").innerText = group.name;
                e.className = "group";

                return e;
            });

            let previous = undefined;
            for (const e of elements) {
                // console.log(e);
                if (e.parentNode == undefined) {
                    if (previous === undefined) {
                        d.appendChild(e);
                    } else {
                        previous.after(e);
                    }
                }
                previous = e;
            }
        }

        async function main() {
            await update();

            async function toggle(groupID, turnOn) {
                const group = data.groups[groupID];
                const connections = getConnectedComponents(group, data);
                const powerManagedZone = connections.find(connection => connection.metadata.name === "Power Managed Zone" && connection.metadata.manufacturer === "Callionica");

                if (powerManagedZone) {
                    // const powerLevelSensor = powerManagedZone.sensors.find(sensor => sensor.modelid === "PM.Zone.PowerLevel")?.id;

                    // await setSensorValue(connection, powerLevelSensor, turnOn ? 2 : 0);

                    const action = powerManagedZone.sensors.find(sensor => sensor.modelid === "PM.Zone.Action")?.id;

                    // Use the dimmer button actions to toggle the lights
                    await setSensorValue(connection, action, turnOn ? 1000 : 4002);
                } else {
                    await setGroupOn(connection, groupID, turnOn);
                }
            }

            function selectAction(e) {
                const removeSelection = (e.dataset.selected === "true");

                let container = e.parentNode;
                while (container) {
                    if (container.dataset.selectGroup === "true") {
                        break;
                    }
                    container = container.parentNode;
                }

                if (container == undefined) {
                    return;
                }

                const selected = container.querySelectorAll("[data-selected='true']");
                for (const s of selected) {
                    delete s.dataset.selected;
                }

                if (!removeSelection) {
                    e.dataset.selected = true;
                } else {
                    delete e.dataset.selected;
                }
            }

            function toggleAction(src) {
                while (src && src.dataset.group == undefined) {
                    src = src.parentNode;
                }

                if (src == undefined) {
                    return;
                }

                const id = src.dataset.group;
                const turnOn = src.dataset.turnOn === "true";
                // let turnOn = src.dataset.on === "false";
                // if (src.dataset.powerLevel != undefined) {
                //     turnOn = src.dataset.powerLevel !== "2";
                // }
                toggle(id, turnOn).then(x => {
                    setTimeout(() => update().then(x => console.log(x)), 0.2 * 1000);
                });
            }

            document.onclick = (evt) => {
                let src = evt.srcElement;
                
                while (src && src.dataset.action == undefined) {
                    src = src.parentNode;
                }
                
                if (src == undefined) {
                    return;
                }

                const action = src.dataset.action;

                if (action === "toggle") {
                    toggleAction(src);
                    return;
                }

                if (action === "select") {
                    selectAction(src);
                    return;
                }
            };

            const updateInterval = 2.0 * 1000;
            window.setInterval(() => {
                update().then(x => console.log("Update"));
            }, updateInterval);
        }

        main().then(x => console.log("Initial"));
        
    </script>
</head>
<body data-page="groups">
    <h1>Rooms & Zones</h1>
    <hr/>
    <div id="data" data-select-group="true"></div>
    <!--<iframe src=""></iframe>-->
</body>
</html>
